---
name: orchestrate
description: Agent Teams를 구성하여 복잡한 작업을 병렬/분산 처리
---

Agent Teams를 활용하여 복잡한 작업을 여러 에이전트에게 분산·병렬 처리합니다.

## 인자

$ARGUMENTS - 수행할 작업 설명 (선택사항. 없으면 현재 컨텍스트에서 판단)

## 사용법

```
/orchestrate 코드베이스 전체 보안 감사
/orchestrate 프론트엔드 + 백엔드 API 동시 구현
/orchestrate
```

---

## 실행 절차

### 0단계: 입력 확인 (State Contract)

`/orchestrate`가 `/deep-plan` 파이프라인에서 호출된 경우:

1. **계획서 파일 확인**: 전달된 `.ai/plans/` 경로의 계획서를 읽는다
2. **단계별 구현 계획 추출**: 계획서의 "단계별 구현 계획" 섹션을 작업 분배의 기준으로 사용
3. **작업 유형 태그 확인**: 보안/비즈니스 유형이면 보안 민감 작업 규칙 적용
4. **C6 Hard Gate 결과 확인**: 통과 상태면 정상 진행, 실패면 `/orchestrate` 거부

`/deep-plan` 없이 독립 호출된 경우:
- 0.5단계(적합성 판단)부터 정상 진행

**파이프라인 연결 예시:**
```
/deep-plan 사용자 인증 시스템 구현
  → 수렴 완료 → 사용자가 "/orchestrate로 병렬 구현" 선택
  → /orchestrate 계획서=.ai/plans/2026-02-28_1430_사용자-인증-시스템.md 유형=보안 C6=통과
  → 0단계에서 계획서 읽기 → 0.5단계 건너뛰고 계획서 기반 작업 분배
```

---

### 0.5단계: 오케스트레이션 적합성 판단

다음 **모든 조건**이 충족될 때만 팀을 구성합니다:

| 적합 | 부적합 |
|------|--------|
| 독립적으로 분리 가능한 작업 2개 이상 | 순차 의존성이 강한 단일 흐름 |
| 각 작업이 10분 이상 소요 예상 | 단순 파일 수정 1~2개 |
| 병렬 처리 시 실질적인 시간 단축 효과 | 같은 파일을 동시에 수정하는 작업 |

부적합하면 단일 에이전트로 처리하고 사용자에게 이유를 설명합니다.

---

### 1단계: 작업 분해

전체 작업을 독립적인 서브태스크로 분해합니다:

1. **의존성 파악**: 어떤 작업이 다른 작업의 결과를 필요로 하는지 확인
2. **병렬 그룹**: 동시에 실행 가능한 작업 그룹 정의
3. **에이전트 유형 결정**: 각 작업에 적합한 에이전트 타입 선택
   - `general-purpose`: 코드 작성/수정이 필요한 작업 (Edit, Write, Bash 포함)
   - `Explore`: 탐색/분석만 필요한 작업 (읽기 전용)

---

### 2단계: 팀 구성

```
TeamCreate({
  team_name: "작업-이름",
  description: "팀 목적 설명"
})
```

TaskCreate로 태스크 목록 생성:
```
TaskCreate({ subject: "태스크 제목", description: "상세 설명", activeForm: "진행형 설명" })
```

의존성 있는 태스크는 blockedBy 설정:
```
TaskUpdate({ taskId: "3", addBlockedBy: ["1", "2"] })
```

---

### 3단계: 팀원 스폰 및 작업 할당

```
Task({
  subagent_type: "general-purpose",
  name: "에이전트-이름",
  team_name: "작업-이름",
  prompt: "작업 상세 지시사항. 완료 시 TaskUpdate로 완료 표시 후 SendMessage로 결과 보고."
})
```

**팀원 지시 시 필수 포함 내용:**
- 담당 태스크 ID 명시 (`TaskUpdate({ taskId: "N", status: "in_progress" })` 먼저 실행)
- 완료 조건 명확화
- 팀 리더(나)에게 결과 보고 방법: `SendMessage({ type: "message", recipient: "리더이름", ... })`
- JSON 형식 메시지 금지, 일반 텍스트로 소통

---

### 4단계: 모니터링 및 조율

**팀원 메시지 자동 수신** → 폴링/체크 불필요

팀원 idle 알림은 정상 동작이므로 특별히 반응하지 않아도 됩니다.
단, 새 작업 할당이 필요하면 `SendMessage`로 지시:
```
SendMessage({
  type: "message",
  recipient: "에이전트-이름",
  content: "다음 태스크 N을 진행해주세요: ...",
  summary: "다음 태스크 할당"
})
```

블로킹 이슈 발생 시 `broadcast`로 팀 전체에 공지:
```
SendMessage({
  type: "broadcast",
  content: "중요: ... 이슈 발견. 현재 작업 일시 중단하고 확인해주세요.",
  summary: "블로킹 이슈 발생"
})
```

---

### 5단계: 2단계 검증 (Two-Stage Review)

팀원 작업이 완료될 때마다 2단계 검증을 수행합니다:

**Stage 1 — 스펙 준수 검증 (Spec Compliance)**
Explore 서브에이전트를 스폰하여 읽기 전용으로 검증:
- 원래 요구사항(작업 지시)과 실제 구현이 일치하는가?
- 요구사항에 있는데 빠진 것은 없는가?
- 요구사항에 없는데 추가된 것은 없는가? (스코프 크리프)
- 결과: 스펙 준수 / 미준수 (구체적 항목 명시)

Stage 1 미통과 → 해당 팀원에게 수정 지시 (Stage 2 진행하지 않음)

**Stage 2 — 코드 품질 검증 (Code Quality)**
Stage 1 통과 후, git diff를 기반으로 검증:
- JINHAK 코딩 컨벤션 준수 (CODING_CONVENTIONS.md)
- 금지 패턴 12개 해당 여부 (FORBIDDEN_PATTERNS.md)
- 에러 처리 누락 여부
- 테스트 코드 존재 여부 (비즈니스 로직인 경우)
- 결과: 품질 통과 / 개선 필요 (항목별 피드백)

Stage 2 미통과 → 피드백과 함께 팀원에게 수정 지시

**두 Stage 모두 통과해야 해당 태스크를 completed로 마킹합니다.**

모든 태스크 완료 확인:
```
TaskList()  // 모든 태스크 completed 확인
```

---

### 6단계: 팀 종료

```
// 각 팀원에게 종료 요청
SendMessage({ type: "shutdown_request", recipient: "에이전트-이름", content: "작업 완료" })

// 모든 팀원 종료 확인 후
TeamDelete()
```

---

## 오케스트레이션 패턴 예시

### 패턴 1: 전체 코드베이스 분석
```
팀: [분석가-1: 프론트엔드] [분석가-2: 백엔드] [분석가-3: DB]
→ 각 영역 병렬 분석 → 결과 통합 리포트
```

### 패턴 2: 풀스택 기능 구현
```
팀: [백엔드-에이전트: API + DB] [프론트엔드-에이전트: UI + 상태관리]
→ API 스펙 먼저 확정(의존성) → 병렬 구현
```

### 패턴 3: 대규모 리팩토링
```
팀: [탐색-에이전트(Explore): 현황 파악] → [리팩터-에이전트들: 모듈별 병렬 처리]
isolation: "worktree" 활용으로 안전한 격리 환경에서 실행
```

---

## 주의사항

- `/orchestrate` 후 팀원들이 같은 파일을 동시에 수정하지 않도록 작업 범위를 명확히 분리
- 팀원은 `target_agent_id`가 아닌 **name**으로 참조 (`~/.claude/teams/{team-name}/config.json` 확인)
- 팀원에게 JSON 상태 메시지 전송 금지 → 일반 텍스트로 소통
- 전체 작업 완료 전 `TeamDelete` 호출 금지 (활성 팀원 있으면 실패)

---

## 합리화 방지

이 스킬의 단계를 건너뛰려는 다음 이유들은 유효하지 않습니다:

- "이 작업은 병렬화할 필요 없이 순차로 하겠습니다" → /orchestrate가 호출된 이상 병렬 분배를 검토해야 합니다. 순차가 적절하다면 사용자에게 확인을 구합니다.
- "Stage 1(스펙 준수)은 명백하므로 Stage 2(코드 품질)로 바로 넘어갑니다" → 스펙 준수가 명백해 보여도 누락/스코프 크리프는 Stage 1에서만 잡힙니다. 건너뛰지 않습니다.

단계를 건너뛸 유일한 방법: 사용자가 명시적으로 해당 단계 생략을 지시
