# JINHAK 바이브 코딩 가이드

이 문서는 AI(Claude)와 함께 코딩하는 "바이브 코딩" 방법론을 설명합니다.
개발자뿐 아니라 기획자, 디자이너 등 비개발자도 활용할 수 있도록 작성되었습니다.

---

## 1. 바이브 코딩이란?

바이브 코딩(Vibe Coding)은 **AI를 페어 프로그래밍 파트너로 활용하는 개발 방식**입니다.

기존의 코드를 한 줄씩 직접 작성하는 방식과 달리, 자연어로 의도를 전달하고 AI가 코드를 생성하면 개발자가 검토·수정하는 협업 방식입니다.

### 핵심 개념

```
전통적 코딩:   개발자 → 코드 작성 → 테스트 → 배포
바이브 코딩:   개발자 ←→ AI 대화 → 코드 생성 → 검토 → 배포
```

### 바이브 코딩이 적합한 상황

| 적합한 경우 | 주의가 필요한 경우 |
|------------|-----------------|
| 프로토타입 빠르게 만들기 | 보안이 극히 중요한 코드 (별도 보안 검증 필수) |
| CRUD 기능 구현 | 성능 최적화가 핵심인 로직 (프로파일링 결과 제공 권장) |
| UI 컴포넌트 개발 | 도메인 전문 지식이 필요한 로직 (맥락 충분히 제공) |
| 보일러플레이트 코드 생성 | |
| 테스트 코드 작성 | |
| 문서화 작업 | |
| 코드 리뷰 및 리팩토링 | |
| 대규모 코드베이스 분석 (1M 컨텍스트) | |

---

## 2. 시작하기: 도구 선택

### 2.1 Claude Code (CLI) - 개발자용

터미널에서 직접 코드를 읽고, 수정하고, 실행할 수 있는 도구입니다.

**장점:**
- 프로젝트 파일을 직접 읽고 수정 가능
- git 커밋, 빌드, 테스트 등 자동 수행
- 프로젝트 컨텍스트(CLAUDE.md)를 자동으로 인식

**사용 방법:**
```bash
# 프로젝트 디렉토리에서 실행
cd my-project
claude

# 지시 예시
> 사용자 프로필 페이지를 추가해줘. PageHeader 컴포넌트를 사용하고 역할은 developer야.
```

### 2.2 Claude.ai (웹) - 모든 직군용

브라우저에서 대화형으로 코드를 생성하거나 기술적 질문을 할 수 있습니다.

**장점:**
- 별도 설치 없이 브라우저에서 사용
- 코드뿐 아니라 기획, 설계, 문서 작성에도 활용 가능
- 이미지(와이어프레임, 다이어그램)를 입력으로 제공 가능

**사용 방법:**
1. claude.ai 접속
2. 프로젝트 생성 또는 기존 프로젝트 선택
3. 이 표준 문서를 프로젝트 지식으로 등록
4. 대화 시작

---

## 3. Claude와 효과적으로 협업하는 방법

### 3.1 프로젝트 설정 (가장 중요!)

AI와의 협업 품질은 **프로젝트 설정에 80%가 결정**됩니다.

```
프로젝트루트/
├── CLAUDE.md              ← AI가 프로젝트를 이해하는 핵심 파일
├── .claude/
│   ├── settings.json      ← 권한 및 자동화 설정
│   └── skills/            ← 반복 작업 자동화
└── .ai/
    ├── SESSION_LOG.md     ← 작업 이력 (AI가 이전 작업을 기억)
    ├── CURRENT_SPRINT.md  ← 현재 할 일 목록
    └── DECISIONS.md       ← 기술 결정 기록
```

**CLAUDE.md에 반드시 포함할 내용:**
1. 프로젝트 한 줄 설명
2. 기술 스택 목록
3. 프로젝트 폴더 구조
4. 주요 명령어 (설치, 실행, 빌드, 테스트)
5. 핵심 개발 규칙
6. 응답 언어 설정 (한국어)

### 3.2 좋은 프롬프트 작성법

#### 기본 구조: 맥락 → 요청 → 제약조건

```
[맥락] 현재 대시보드 페이지에서 사용자별 목표 진행률을 보여주고 있어.
[요청] 여기에 부서별 필터 기능을 추가해줘.
[제약] Select 컴포넌트는 공유 UI에서 가져오고,
       필터 상태는 URL 파라미터로 관리해줘.
```

#### 좋은 프롬프트 예시

```
# 구체적이고 맥락이 있는 요청
"apps/prototype/src/pages/developer/에 ProjectDetailPage.jsx를 만들어줘.
DashboardLayout으로 감싸고, PageHeader에 프로젝트명과 상태를 표시해.
프로젝트 데이터는 data/projects.js에서 가져와."

# 기존 코드를 참조하는 요청
"GoalCard 컴포넌트처럼 같은 스타일로 ProjectCard를 만들어줘.
진행률 표시는 Progress 컴포넌트를 사용해."

# 단계적 요청
"1단계: 먼저 데이터 구조를 정의해줘 (data/projects.js)
 2단계: ProjectCard 컴포넌트를 만들어줘
 3단계: ProjectListPage에서 카드 목록을 표시해줘"
```

#### 나쁜 프롬프트 예시

```
# 너무 모호함
"프로젝트 페이지 만들어줘"
→ 어떤 정보를 표시할지, 어떤 레이아웃을 사용할지 불명확

# 너무 많은 요구사항을 한번에
"프로젝트 관리 시스템 전체를 만들어줘. CRUD, 필터, 정렬, 페이지네이션,
 대시보드 위젯, 알림, 권한 관리까지 다 포함해서."
→ 작은 단위로 나누어 요청하는 것이 품질이 높음

# 결과물만 요구
"버그 고쳐"
→ 어떤 버그인지, 어떻게 재현되는지, 기대 동작은 무엇인지 설명 필요
```

### 3.3 대화 패턴

#### 점진적 구축 패턴 (권장)

```
개발자: "먼저 프로젝트 목록 데이터 구조를 정의해줘"
AI:     [데이터 구조 생성]
개발자: "좋아. 이 데이터를 표시하는 카드 컴포넌트를 만들어줘"
AI:     [컴포넌트 생성]
개발자: "카드에 진행률 바를 추가하고, 클릭하면 상세 페이지로 이동하게 해줘"
AI:     [기능 추가]
```

#### 리뷰 요청 패턴

```
개발자: "방금 만든 코드를 리뷰해줘. 특히 이 부분이 맞는지 확인해:
        1. 스토어 구조가 컨벤션에 맞는지
        2. 에러 처리가 적절한지
        3. 성능 문제가 없는지"
```

#### 문제 해결 패턴

```
개발자: "이 에러가 발생해:
        [에러 메시지 붙여넣기]

        관련 파일은 src/stores/goalStore.js이고,
        addGoal 함수를 호출할 때 발생해."
```

---

## 4. 비개발자를 위한 가이드

### 4.1 기획자가 Claude와 하는 일

```
# 요구사항 정리
"다음 기능의 요구사항을 정리해줘:
 - 팀 목표 관리 페이지
 - 목표 생성, 수정, 삭제 가능
 - 팀장만 팀 목표 수정 가능
 - 진행률 시각화 필요
 화면 구성과 사용자 시나리오를 작성해줘."

# 데이터 구조 설계
"이 기능에 필요한 데이터 구조를 설계해줘.
 JINHAK 표준에 맞게 ID 형식, 날짜 형식을 적용해."

# 와이어프레임 → 코드
"[스크린샷 첨부] 이 화면을 React 컴포넌트로 구현해줘.
 우리 프로젝트의 공유 UI 컴포넌트를 사용해."
```

### 4.2 디자이너가 Claude와 하는 일

```
# 디자인 시스템 정리
"현재 프로젝트의 색상 변수와 타이포그래피 설정을 정리해줘."

# 컴포넌트 변형 생성
"Button 컴포넌트에 'warning' 변형을 추가해줘.
 기존 destructive와 비슷하지만 노란색 계열로."

# 반응형 레이아웃
"이 대시보드 레이아웃을 모바일에서도 잘 보이게 수정해줘.
 Tailwind의 반응형 클래스를 사용해."
```

---

## 5. 세션 관리 방법

> **Agent Memory**: Opus 4.6부터 Claude Code가 프로젝트별 메모리를 자동으로 관리합니다. 이전 세션의 맥락을 자동으로 회상하므로, `.ai/` 파일은 팀원 간 공유용 핵심 사항만 기록하면 됩니다.

### 5.1 세션 시작

```
# Claude Code에서
/session-start

# PR 기반 세션 시작 (특정 PR의 맥락에서 시작)
claude --from-pr 123

# 또는 수동으로
"이전 작업 내용을 확인해줘. .ai/CURRENT_SPRINT.md를 읽어줘."
```

### 5.2 작업 중

```
# 작업 진행 상황 공유
"현재 목표 관리 페이지의 CRUD 중 Create까지 완료했어.
 다음은 목록 조회 기능을 구현할 거야."

# 막히는 부분 질문
"이 에러 로그를 보고 원인을 분석해줘."

# 복잡한 구현 전 Plan 모드 활용
"이 기능을 구현하기 전에 먼저 계획을 세워줘."
```

### 5.3 세션 종료

```
# Claude Code에서
/commit

# 또는 수동으로
"오늘 작업 내용을 .ai/CURRENT_SPRINT.md에 반영하고 커밋해줘."
```

---

## 6. 주의사항 및 안티패턴

### 6.1 절대 하지 말 것

| 행동 | 이유 |
|------|------|
| AI가 생성한 코드를 검토 없이 커밋 | 버그, 보안 취약점, 컨벤션 위반 가능 |
| `.env` 파일 내용을 AI에게 공유 | API 키, 비밀번호 유출 위험 |
| 한번에 너무 많은 기능 요청 | 품질 저하, 디버깅 어려움 |
| AI의 답변을 무조건 신뢰 | AI도 실수할 수 있음, 항상 검증 필요 |
| 프로덕션 DB 접속 정보를 AI에게 전달 | 보안 사고 위험 |
| 보안 민감 영역 코드를 리뷰 없이 머지 | 인증/결제/개인정보 관련 코드는 시니어 리뷰 필수 |
| AI 추천 패키지를 검증 없이 설치 | 의존성 취약점, typosquatting 위험 |
| 수험생 실제 데이터를 AI 컨텍스트에 포함 | ISMS-P 위반, 개인정보 유출 위험 |

### 6.2 흔한 실수와 해결법

#### 실수 1: "전체를 다시 만들어줘"

```
# 나쁨
"이 파일 전체를 처음부터 다시 작성해줘"

# 좋음
"이 파일의 handleSubmit 함수에서 유효성 검증 부분만 수정해줘"
```

**이유:** 전체 재작성은 기존에 잘 동작하던 부분까지 변경될 위험이 있습니다.

#### 실수 2: 컨텍스트 없는 요청

```
# 나쁨
"버튼이 안 돼"

# 좋음
"DashboardPage의 '저장' 버튼을 클릭하면 handleSave가 호출되지 않아.
 콘솔에 이런 에러가 나와: [에러 메시지]"
```

#### 실수 3: 코드 리뷰 건너뛰기

AI가 생성한 코드는 반드시 다음을 확인하세요:
1. **기능 동작**: 의도한 대로 동작하는가?
2. **컨벤션 준수**: 네이밍, 파일 위치, import 순서가 맞는가?
3. **보안**: 사용자 입력을 적절히 검증하는가?
4. **불필요한 코드**: 요청하지 않은 기능이 추가되지 않았는가?

### 6.3 AI 협업 시 주의가 필요한 영역

> Opus 4.6은 1M 컨텍스트, Agent Teams, Adaptive Thinking으로 이전 모델 대비 크게 향상되었지만, 다음 영역은 여전히 사람의 판단이 중요합니다.

- **프로젝트의 비즈니스 맥락**: 도메인 지식은 개발자가 충분히 제공해야 정확한 결과물이 나옴
- **기존 코드와의 사이드 이펙트**: 대규모 코드베이스에서 간접 의존성을 놓칠 수 있음 (Agent Teams으로 병렬 분석 권장)
- **성능 최적화**: 프로파일링 결과를 함께 제공하면 정확도가 크게 향상됨
- **보안 취약점 100% 탐지**: OWASP Top 10 수준은 잘 감지하지만, 복합적인 보안 이슈는 별도 검증 필요
- **실시간 외부 서비스 상태**: API 가용성, 인프라 상태 등은 AI가 직접 확인할 수 없음

### 6.4 AI 안티패턴 상세 목록

AI와 협업할 때 발생할 수 있는 안티패턴을 3개 카테고리로 분류합니다.

#### 카테고리 1: 위험한 요청

| 안티패턴 | 구체적 예시 | 위험도 | 올바른 대안 |
|---------|-----------|--------|-----------|
| 강제 push 요청 | "git push --force로 덮어써" | 높음 | 새 커밋으로 수정 후 일반 push |
| 이력 초기화 | "git reset --hard로 되돌려" | 높음 | git revert로 안전하게 되돌리기 |
| hook 우회 | "--no-verify로 커밋해" | 높음 | hook 문제를 해결 후 정상 커밋 |
| 프로덕션 DB 직접 조작 | "프로덕션 DB에서 직접 삭제해" | 높음 | 스테이징 환경에서 테스트 후 마이그레이션 |
| 전체 삭제 명령 | "rm -rf로 다 지워" | 높음 | 삭제 대상을 명시적으로 지정 |

#### 카테고리 2: 민감 정보 노출

| 안티패턴 | 구체적 예시 | 위험도 | 올바른 대안 |
|---------|-----------|--------|-----------|
| 비밀키 공유 | "이 API Key로 설정해: sk-abc..." | 높음 | Vault에 저장 후 환경변수로 참조 |
| DB 접속정보 공유 | "DB 비밀번호는 P@ss1234야" | 높음 | Vault에서 동적 발급 |
| .env 내용 공유 | ".env 파일 내용 보여줘" | 중간 | .env.example로 구조만 공유 |
| 개인정보 포함 | "홍길동(010-1234-5678) 데이터로 테스트해" | 중간 | 가명화된 테스트 데이터 사용 |
| 내부 서버 정보 | "192.168.1.100:5432로 접속해" | 중간 | 환경별 설정 파일로 관리 |

#### 카테고리 3: 품질 저하

| 안티패턴 | 구체적 예시 | 위험도 | 올바른 대안 |
|---------|-----------|--------|-----------|
| 전체 재작성 요청 | "이 파일 전체를 처음부터 다시 써" | 중간 | 문제 부분만 지정하여 수정 요청 |
| 과도한 기능 요청 | "순차 의존성 있는 기능을 한번에 5개 이상" | 중간 | 의존성 있는 기능은 3개 이하로 분할, 독립 작업은 Agent Teams 활용 가능 |
| 무검증 적용 | "그냥 빨리 머지해" | 중간 | 코드 리뷰 후 머지 |
| 맥락 없는 요청 | "버그 고쳐" | 낮음 | 에러 메시지, 재현 방법, 기대 동작 함께 제공 |
| AI 맹신 | "AI가 만든 거니까 괜찮겠지" | 중간 | 기능/보안/컨벤션 3가지 관점에서 반드시 리뷰 |

### 6.5 안티패턴 자동 감지 메커니즘

Claude는 위 안티패턴을 다음 규칙에 따라 자동으로 감지하고 대응합니다.

**감지 시 Claude의 행동 규칙:**

1. **위험한 요청 감지**: 실행을 거부하고, 안전한 대안을 즉시 제시
2. **민감 정보 감지**: 경고를 출력하고, 정보 제거 또는 마스킹 후 진행 요청
3. **품질 저하 감지**: 경고와 함께 더 나은 접근 방법을 제안 (실행은 사용자 판단)

**대화 예시:**

```
# 위험한 요청 감지
사용자: "git push --force로 원격 브랜치를 덮어써줘"
Claude: "push --force는 원격 저장소의 커밋 이력을 파괴할 수 있어 실행할 수 없습니다.
        대안: 새로운 커밋을 만들어 일반 push를 사용하겠습니다.
        이전 커밋을 되돌려야 하면 git revert를 사용할 수 있습니다."

# 민감 정보 감지
사용자: "이 API Key(sk-abc123def456)로 환경변수 설정해줘"
Claude: "프롬프트에 실제 API Key가 포함되어 있습니다.
        API Key는 Vault에 저장하고, 코드에서는 환경변수로 참조해야 합니다.
        Vault에 저장하는 절차를 안내해 드릴까요?"

# 품질 저하 감지
사용자: "이 파일 전체를 처음부터 다시 작성해줘"
Claude: "전체 재작성은 기존에 동작하던 코드까지 변경될 위험이 있습니다.
        수정이 필요한 구체적인 부분을 알려주시면 해당 부분만 수정하겠습니다.
        어떤 부분이 문제인가요?"
```

### 6.6 Opus 4.6 신기능 활용법

#### Agent Teams (멀티 에이전트 병렬 작업)

여러 에이전트가 팀을 이루어 독립적인 작업을 병렬로 수행합니다.

```
# 적합한 요청
"이 프로젝트의 모든 API 엔드포인트를 분석해줘"
→ Agent Teams가 각 모듈을 병렬로 분석

# 적합한 요청
"src/components 폴더의 모든 컴포넌트를 리뷰해줘"
→ 각 컴포넌트를 독립적으로 병렬 리뷰

# 부적합한 요청 (순차 의존성)
"DB 스키마 설계 → API 구현 → 프론트 연동을 한번에"
→ 각 단계가 이전 단계에 의존하므로 순차적으로 요청
```

#### Plan 모드 (구현 전 설계 검토)

복잡한 기능을 구현하기 전에 Plan 모드로 설계를 먼저 검토합니다.

```
# Plan 모드 활용이 좋은 경우
- 3개 이상 파일을 수정하는 기능
- 아키텍처 결정이 필요한 신규 기능
- .ai/DECISIONS.md에 기록할 수준의 기술 결정

# 사용법
"이 기능을 구현하기 전에 먼저 계획을 세워줘"
→ Claude가 Plan 모드로 전환, 설계를 제안 → 승인 후 구현
```

#### Effort 설정 활용

작업 복잡도에 따라 AI의 추론 깊이를 조절합니다.

| Effort | 적합한 작업 |
|--------|-----------|
| `low` | 오타 수정, 이름 변경, 간단한 포맷팅 |
| `medium` | 일반 CRUD, 단순 컴포넌트 |
| `high` (기본) | 복잡한 비즈니스 로직, 버그 분석 |
| `max` | 아키텍처 설계, 보안 감사 |

### 6.7 AI 보안 체크 워크플로우 (v2.0)

AI와 협업할 때 보안을 유지하기 위한 단계별 워크플로우입니다.

#### 코딩 전 (입력 보안)
```
1. AI에게 전달할 데이터에 개인정보/비밀키가 없는지 확인
2. 실제 데이터 대신 가명화된 테스트 데이터 사용
3. .env 파일 내용을 절대 프롬프트에 포함하지 않기
```

#### 코딩 중 (코드 생성 보안)
```
1. AI가 생성한 코드에 금지 패턴(eval, SQL 연결 등)이 없는지 확인
2. 보안 민감 영역(인증, 결제)은 반드시 직접 검토
3. 새 패키지 추천 시 npm audit + 다운로드 수 확인
```

#### 코딩 후 (출력 검증)
```
1. /security-check 실행하여 자동 보안 점검
2. 변경사항에 시크릿이 포함되지 않았는지 확인
3. 보안 민감 코드는 PR에서 시니어 리뷰 요청
```

#### 커밋/배포 전
```
1. git diff로 최종 변경 내용 확인
2. .env, credentials 등 민감 파일이 스테이징되지 않았는지 확인
3. /commit으로 표준에 맞는 커밋 생성
```

> 상세 보안 가이드레일: [security/AI_SECURITY_GUARDRAILS.md](./security/AI_SECURITY_GUARDRAILS.md)
> 금지 코드 패턴: [security/FORBIDDEN_PATTERNS.md](./security/FORBIDDEN_PATTERNS.md)

---

## 7. 팀 협업 베스트 프랙티스

### 7.1 CLAUDE.md 관리

- CLAUDE.md는 **팀 전체가 함께 관리**하는 문서
- 새로운 패턴이나 규칙이 정해지면 즉시 업데이트
- PR 리뷰 시 CLAUDE.md 업데이트 여부도 확인

### 7.2 세션 로그 활용

- 다른 팀원의 작업 내용을 `.ai/SESSION_LOG.md`에서 확인
- AI 세션 시작 시 이전 작업 이력을 자동으로 참고
- 충돌 방지: 같은 파일을 동시에 작업하지 않도록 조율

### 7.3 지식 공유

- 효과적이었던 프롬프트는 팀 내 공유
- 반복 작업은 Skills(슬래시 명령어)로 자동화
- 기술 결정은 `.ai/DECISIONS.md`에 ADR 형식으로 기록

---

## 8. 빠른 참조 카드

### 개발자용

```bash
# 프로젝트 시작
cd my-project && claude

# 세션 시작
/session-start

# 코딩 작업
"UserCard 컴포넌트를 만들어줘. 공유 UI의 Card를 사용하고..."

# 커밋
/commit

# PR 리뷰
/review-pr 123
```

### 비개발자용 (Claude.ai)

```
1. claude.ai 접속
2. 프로젝트 지식에 이 표준 문서 업로드
3. 대화 시작:

"우리 프로젝트 표준에 맞게 [요구사항]을 정리해줘"
"이 화면의 데이터 구조를 설계해줘"
"이 기능의 사용자 시나리오를 작성해줘"
```

---

## 9. 트러블슈팅

### 9.1 Hook이 실행되지 않을 때
1. `.claude/settings.json` 파일 위치 확인 (프로젝트 루트)
2. JSON 문법 오류 확인 (쉼표, 따옴표 누락 등)
3. 명령어 경로가 올바른지 확인
4. Windows/macOS/Linux 환경에 맞는 명령어인지 확인

### 9.2 슬래시 명령어가 인식되지 않을 때
1. `.claude/skills/[명령어명]/SKILL.md` 경로 확인 (대문자 SKILL.md)
2. YAML frontmatter에 `name`과 `description`이 있는지 확인
3. 디렉토리명에 특수문자가 없는지 확인
4. Claude Code 재시작 후 재시도

### 9.3 커밋 실패 시
1. pre-commit hook 로그 확인
2. 스테이징된 파일 확인 (`git status`)
3. 문제 해결 후 **새 커밋**으로 재시도 (amend 금지)

### 9.4 세션 컨텍스트가 유실될 때
- `.ai/CURRENT_SPRINT.md`와 `.ai/SESSION_LOG.md`가 있는지 확인
- `/session-start`로 세션을 시작하면 이전 컨텍스트를 자동으로 로드
- Opus 4.6의 **Context Compaction**이 장시간 세션에서 이전 대화를 자동 요약 (1M 컨텍스트)
- Agent Memory가 프로젝트별 메모리를 자동 관리하므로, 이전 세션 맥락이 대부분 자동 복원됨
- 그래도 핵심 결정 사항은 `.ai/DECISIONS.md`에 명시적으로 기록 권장

---

*이 문서는 [JINHAK 전사 AI 개발 표준](./CLAUDE.md)의 상세 문서입니다.*
